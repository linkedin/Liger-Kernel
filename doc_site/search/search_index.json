{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#liger-kernel-efficient-triton-kernels-for-llm-training","title":"Liger Kernel: Efficient Triton Kernels for LLM Training","text":"Stable Nightly Discord Build <p>Liger Kernel is a collection of Triton kernels designed specifically for LLM training. It can effectively increase multi-GPU training throughput by 20% and reduces memory usage by 60%. We have implemented Hugging Face Compatible <code>RMSNorm</code>, <code>RoPE</code>, <code>SwiGLU</code>, <code>CrossEntropy</code>, <code>FusedLinearCrossEntropy</code>, and more to come. The kernel works out of the box with Flash Attention, PyTorch FSDP, and Microsoft DeepSpeed. We welcome contributions from the community to gather the best kernels for LLM training.</p> <p>We've also added optimized Post-Training kernels that deliver up to 80% memory savings for alignment and distillation tasks. We support losses like DPO, CPO, ORPO, SimPO, JSD, and many more. Check out how we optimize the memory.</p>"},{"location":"#supercharge-your-model-with-liger-kernel","title":"Supercharge Your Model with Liger Kernel","text":"<p>With one line of code, Liger Kernel can increase throughput by more than 20% and reduce memory usage by 60%, thereby enabling longer context lengths, larger batch sizes, and massive vocabularies.</p> Speed Up Memory Reduction <p>Note: - Benchmark conditions: LLaMA 3-8B, Batch Size = 8, Data Type = <code>bf16</code>, Optimizer = AdamW, Gradient Checkpointing = True, Distributed Strategy = FSDP1 on 8 A100s. - Hugging Face models start to OOM at a 4K context length, whereas Hugging Face + Liger Kernel scales up to 16K.</p>"},{"location":"#optimize-post-training-with-liger-kernel","title":"Optimize Post Training with Liger Kernel","text":"<p>We provide optimized post training kernels like DPO, ORPO, SimPO, and more which can reduce memory usage by up to 80%. You can easily use them as python modules.</p> <pre><code>from liger_kernel.chunked_loss import LigerFusedLinearDPOLoss\norpo_loss = LigerFusedLinearORPOLoss()\ny = orpo_loss(lm_head.weight, x, target)\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Ease of use: Simply patch your Hugging Face model with one line of code, or compose your own model using our Liger Kernel modules.</li> <li>Time and memory efficient: In the same spirit as Flash-Attn, but for layers like RMSNorm, RoPE, SwiGLU, and CrossEntropy! Increases multi-GPU training throughput by 20% and reduces memory usage by 60% with kernel fusion, in-place replacement, and chunking techniques.</li> <li>Exact: Computation is exact\u2014no approximations! Both forward and backward passes are implemented with rigorous unit tests and undergo convergence testing against training runs without Liger Kernel to ensure accuracy.</li> <li>Lightweight: Liger Kernel has minimal dependencies, requiring only Torch and Triton\u2014no extra libraries needed! Say goodbye to dependency headaches!</li> <li>Multi-GPU supported: Compatible with multi-GPU setups (PyTorch FSDP, DeepSpeed, DDP, etc.).</li> <li>Trainer Framework Integration: Axolotl, LLaMa-Factory, SFTTrainer, Hugging Face Trainer, SWIFT</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>To install the stable version:</p> <pre><code>$ pip install liger-kernel\n</code></pre> <p>To install the nightly version:</p> <pre><code>$ pip install liger-kernel-nightly\n</code></pre> <p>To install from source:</p> <pre><code>git clone https://github.com/linkedin/Liger-Kernel.git\ncd Liger-Kernel\n\n# Install Default Dependencies\n# Setup.py will detect whether you are using AMD or NVIDIA\npip install -e .\n\n# Setup Development Dependencies\npip install -e \".[dev]\"\n</code></pre> <p> Dependencies </p> <p>Optional Dependencies </p> <ul> <li><code>transformers &gt;= 4.x</code>: Required if you plan to use the transformers models patching APIs. The specific model you are working will dictate the minimum version of transformers.</li> </ul> <p>Note</p> <p>Our kernels inherit the full spectrum of hardware compatibility offered by Triton.</p>"},{"location":"#cuda","title":"CUDA","text":"<ul> <li><code>torch &gt;= 2.1.2</code></li> <li><code>triton &gt;= 2.3.0</code></li> </ul>"},{"location":"#rocm","title":"ROCm","text":"<ul> <li><code>torch &gt;= 2.5.0</code> Install according to the instruction in Pytorch official webpage.</li> <li><code>triton &gt;= 3.0.0</code> Install from pypi. (e.g. <code>pip install triton==3.0.0</code>)</li> </ul>"},{"location":"#sponsorship-and-collaboration","title":"Sponsorship and Collaboration","text":"<ul> <li>AMD: Providing AMD GPUs for our AMD CI.</li> <li>Intel: Providing Intel GPUs for our Intel CI.</li> <li>Modal: Free 3000 credits from GPU MODE IRL for our NVIDIA CI.</li> <li>EmbeddedLLM: Making Liger Kernel run fast and stable on AMD. </li> <li>HuggingFace: Integrating Liger Kernel into Hugging Face Transformers and TRL.</li> <li>Lightning AI: Integrating Liger Kernel into Lightning Thunder.</li> <li>Axolotl: Integrating Liger Kernel into Axolotl.</li> <li>Llama-Factory: Integrating Liger Kernel into Llama-Factory.</li> </ul> <p> Contact </p> <ul> <li>For issues, create a Github ticket in this repository .</li> <li>For open discussion, join our discord channel .</li> <li>For formal collaboration, send an email to byhsu@linkedin.com .</li> </ul>"},{"location":"#cite-this-work","title":"Cite this work","text":"<p>Bib Latex entry: <pre><code>@article{hsu2024ligerkernelefficienttriton,\n      title={Liger Kernel: Efficient Triton Kernels for LLM Training},\n      author={Pin-Lun Hsu and Yun Dai and Vignesh Kothapalli and Qingquan Song and Shao Tang and Siyu Zhu and Steven Shimizu and Shivam Sahni and Haowen Ning and Yanning Chen},\n      year={2024},\n      eprint={2410.10989},\n      archivePrefix={arXiv},\n      primaryClass={cs.LG},\n      url={https://arxiv.org/abs/2410.10989},\n      journal={arXiv preprint arXiv:2410.10989},\n}\n</code></pre></p>"},{"location":"#star-history","title":"Star History","text":"<p>          \u2191 Back to Top \u2191      </p>"},{"location":"Examples/","title":"Examples","text":"<p>HANDS-ON USECASE EXAMPLES</p> Use Case Description Hugging Face Trainer Train LLaMA 3-8B ~20% faster with over 40% memory reduction on Alpaca dataset using 4 A100s with FSDP Lightning Trainer Increase 15% throughput and reduce memory usage by 40% with LLaMA3-8B on MMLU dataset using 8 A100s with DeepSpeed ZeRO3 Medusa Multi-head LLM (Retraining Phase) Reduce memory usage by 80% with 5 LM heads and improve throughput by 40% using 8 A100s with FSDP Vision-Language Model SFT Finetune Qwen2-VL on image-text data using 4 A100s with FSDP Liger ORPO Trainer Align Llama 3.2 using Liger ORPO Trainer with FSDP with 50% memory reduction"},{"location":"Examples/#huggingface-trainer","title":"HuggingFace Trainer","text":""},{"location":"Examples/#how-to-run","title":"How to Run","text":""},{"location":"Examples/#locally-on-a-gpu-machine","title":"Locally on a GPU machine","text":"<p>You can run the example locally on a GPU machine. The default hyperparameters and configurations work on single node with 4xA100 80GB GPUs and FSDP.</p> <p>Example</p> <pre><code>pip install -r requirements.txt\nsh run_{MODEL}.sh\n</code></pre>"},{"location":"Examples/#remotely-on-modal","title":"Remotely on Modal","text":"<p>If you do not have access to a GPU machine, you can run the example on Modal. Modal is a serverless platform that allows you to run your code on a remote GPU machine. You can sign up for a free account at Modal.</p> <p>Example</p> <pre><code>pip install modal\nmodal setup  # authenticate with Modal\nmodal run launch_on_modal.py --script \"run_qwen2_vl.sh\"\n</code></pre> <p>Notes</p> <ol> <li> <p>This example uses an optional <code>use_liger</code> flag. If true, it does a 1 line monkey patch to apply liger kernel.</p> </li> <li> <p>The example uses Llama3 model that requires community license agreement and HuggingFace Hub login. If you want to use Llama3 in this example, please make sure you have done the following:</p> <ul> <li>Agree on the community license agreement .</li> <li>Run <code>huggingface-cli login</code> and enter your HuggingFace token.</li> </ul> </li> <li> <p>The default hyperparameters and configurations work on single node with 4xA100 80GB GPUs. For running on device with less GPU RAM, please consider reducing the per-GPU batch size and/or enable <code>CPUOffload</code> in FSDP.</p> </li> </ol>"},{"location":"Examples/#benchmark-result","title":"Benchmark Result","text":""},{"location":"Examples/#llama","title":"Llama","text":"<p>Info</p> <p>Benchmark conditions:  Model= LLaMA 3-8B,Datset= Alpaca, Max seq len = 512, Data Type = bf16, Optimizer = AdamW, Gradient Checkpointing = True, Distributed Strategy = FSDP1 on 4 A100s.</p> <p>Throughput improves by around 20%, while GPU memory usage drops by 40%. This allows you to train the model on smaller GPUs, use larger batch sizes, or handle longer sequence lengths without incurring additional costs.</p> <p> </p>"},{"location":"Examples/#qwen","title":"Qwen","text":"<p>Info</p> <p>Benchmark conditions: Model= Qwen2-7B, Dataset= Alpaca, Max seq len = 512, Data Type = bf16, Optimizer = AdamW, Gradient Checkpointing = True, Distributed Strategy = FSDP1 on 4 A100s.</p> <p>Throughput improves by around 10%, while GPU memory usage drops by 50%.</p> <p> </p>"},{"location":"Examples/#gemma-7b","title":"Gemma 7B","text":"<p>Info</p> <p>Benchmark conditions: Model= Gemma-7B, Dataset= Alpaca, Max seq len = 512, Data Type = bf16, Optimizer = AdamW, Gradient Checkpointing = True, Distributed Strategy = FSDP1 on 4 A100s.</p> <p>Throughput improves by around 24%, while GPU memory usage drops by 33%.</p> <p> </p>"},{"location":"Examples/#lightning-trainer","title":"Lightning Trainer","text":""},{"location":"Examples/#how-to-run_1","title":"How to Run","text":""},{"location":"Examples/#locally-on-a-gpu-machine_1","title":"Locally on a GPU machine","text":"<p>You can run the example locally on a GPU machine.</p> <p>Example</p> <pre><code>pip install -r requirements.txt\n\n# For single L40 48GB GPU\npython training.py --model Qwen/Qwen2-0.5B-Instruct --num_gpu 1 --max_length 1024\n\n# For 8XA100 40GB\npython training.py --model meta-llama/Meta-Llama-3-8B --strategy deepspeed\n</code></pre> <p>Notes</p> <ol> <li> <p>The example uses Llama3 model that requires community license agreement and HuggingFace Hub login. If you want to use Llama3 in this example, please make sure you have done the following:</p> <ul> <li>Agree on the community license agreement</li> <li>Run <code>huggingface-cli login</code> and enter your HuggingFace token.</li> </ul> </li> <li> <p>The default hyperparameters and configurations for gemma works on single L40 48GB GPU and config for llama work on single node with 8xA100 40GB GPUs. For running on device with less GPU RAM, please consider reducing the per-GPU batch size and/or enable <code>CPUOffload</code> in FSDP.</p> </li> </ol>"},{"location":"Examples/#medusa","title":"Medusa","text":"<p>Medusa is a simple framework that democratizes the acceleration techniques for LLM generation with multiple decoding heads. To know more, you can check out the repo and the paper .</p> <p>The Liger fused CE kernel is highly effective in this scenario, eliminating the need to materialize logits for each head, which usually consumes a large volume of memory due to the extensive vocabulary size (e.g., for LLaMA-3, the vocabulary size is 128k).</p> <p>The introduction of multiple heads can easily lead to OOM (Out of Memory) issues. However, thanks to the efficient Liger fused CE, which calculates the gradient in place and doesn't materialize the logits, we have observed very effective results. This efficiency opens up more opportunities for multi-token prediction research and development.</p>"},{"location":"Examples/#how-to-run_2","title":"How to Run","text":"<p>Example</p> <pre><code>git clone git@github.com:linkedin/Liger-Kernel.git\ncd {PATH_TO_Liger-Kernel}/Liger-Kernel/\npip install -e .\ncd {PATH_TO_Liger-Kernel}/Liger-Kernel/examples/medusa\npip install -r requirements.txt\nsh scripts/llama3_8b_medusa.sh\n</code></pre> <p>Notes</p> <ol> <li> <p>This example uses an optional <code>use_liger</code> flag. If true, it does a monkey patch to apply liger kernel with medusa heads.</p> </li> <li> <p>The example uses Llama3 model that requires community license agreement and HuggingFace Hub login. If you want to use Llama3 in this example, please make sure you have done the followings:</p> <ul> <li>Agree on the community license agreement https://huggingface.co/meta-llama/Meta-Llama-3-8B</li> <li>Run <code>huggingface-cli login</code> and enter your HuggingFace token</li> </ul> </li> <li> <p>The default hyperparameters and configurations work on single node with 8xA100 GPUs. For running on device with less GPU RAM, please consider reducing the per-GPU batch size and/or enable <code>CPUOffload</code> in FSDP.</p> </li> <li> <p>We are using a smaller sample of shared GPT data primarily to benchmark performance. The example requires hyperparameter tuning and dataset selection to work effectively, also ensuring the dataset has the same distribution as the LLaMA pretraining data. Welcome contribution to enhance the example code.</p> </li> </ol>"},{"location":"Examples/#benchmark-result_1","title":"Benchmark Result","text":"<p>Info</p> <ol> <li>Benchmark conditions: LLaMA 3-8B, Batch Size = 6, Data Type = bf16, Optimizer = AdamW, Gradient Checkpointing = True, Distributed Strategy = FSDP1 on 8 A100s.</li> </ol>"},{"location":"Examples/#stage-1","title":"Stage 1","text":"<p>Stage 1 refers to Medusa-1 where the backbone model is frozen and only weights of LLM heads are updated.</p> <p>Warning</p> <pre><code># Modify this flag in llama3_8b_medusa.sh to True enables stage1 \n--medusa_only_heads True\n</code></pre>"},{"location":"Examples/#num_head-3","title":"num_head = 3","text":""},{"location":"Examples/#num_head-5","title":"num_head = 5","text":""},{"location":"Examples/#stage-2","title":"Stage 2","text":"<p>Warning</p> <pre><code># Modify this flag to False in llama3_8b_medusa.sh enables stage2\n--medusa_only_heads False\n</code></pre> <p>Stage 2 refers to Medusa-2 where all the model weights are updated including the backbone model and llm heads.</p>"},{"location":"Examples/#num_head-3_1","title":"num_head = 3","text":""},{"location":"Examples/#num_head-5_1","title":"num_head = 5","text":""},{"location":"Examples/#vision-language-model-sft","title":"Vision-Language Model SFT","text":""},{"location":"Examples/#how-to-run_3","title":"How to Run","text":""},{"location":"Examples/#locally-on-a-gpu-machine_2","title":"Locally on a GPU Machine","text":"<p>You can run the example locally on a GPU machine. The default hyperparameters and configurations work on single node with 4xA100 80GB GPUs.</p> <p>Example</p> <pre><code>#!/bin/bash\n\ntorchrun --nnodes=1 --nproc-per-node=4 training_multimodal.py \\\n    --model_name \"Qwen/Qwen2-VL-7B-Instruct\" \\\n    --bf16 \\\n    --num_train_epochs 1 \\\n    --per_device_train_batch_size 8 \\\n    --per_device_eval_batch_size 8 \\\n    --eval_strategy \"no\" \\\n    --save_strategy \"no\" \\\n    --learning_rate 6e-6 \\\n    --weight_decay 0.05 \\\n    --warmup_ratio 0.1 \\\n    --lr_scheduler_type \"cosine\" \\\n    --logging_steps 1 \\\n    --include_num_input_tokens_seen \\\n    --report_to none \\\n    --fsdp \"full_shard auto_wrap\" \\\n    --fsdp_config config/fsdp_config.json \\\n    --seed 42 \\\n    --use_liger True \\\n    --output_dir multimodal_finetuning\n</code></pre>"},{"location":"Examples/#orpo-trainer","title":"ORPO Trainer","text":""},{"location":"Examples/#how-to-run_4","title":"How to Run","text":""},{"location":"Examples/#locally-on-a-gpu-machine_3","title":"Locally on a GPU Machine","text":"<p>You can run the example locally on a GPU machine and FSDP.</p> <p>Example</p> <pre><code>import torch\nfrom datasets import load_dataset\nfrom transformers import AutoModelForCausalLM, AutoTokenizer\nfrom trl import ORPOConfig  # noqa: F401\n\nfrom liger_kernel.transformers.trainer import LigerORPOTrainer  # noqa: F401\n\nmodel = AutoModelForCausalLM.from_pretrained(\n    \"meta-llama/Llama-3.2-1B-Instruct\",\n    torch_dtype=torch.bfloat16,\n)\n\ntokenizer = AutoTokenizer.from_pretrained(\n    \"meta-llama/Llama-3.2-1B-Instruct\",\n    max_length=512,\n    padding=\"max_length\",\n)\ntokenizer.pad_token = tokenizer.eos_token\n\ntrain_dataset = load_dataset(\"trl-lib/tldr-preference\", split=\"train\")\n\ntraining_args = ORPOConfig(\n    output_dir=\"Llama3.2_1B_Instruct\",\n    beta=0.1,\n    max_length=128,\n    per_device_train_batch_size=32,\n    max_steps=100,\n    save_strategy=\"no\",\n)\n\ntrainer = LigerORPOTrainer(\n    model=model, args=training_args, tokenizer=tokenizer, train_dataset=train_dataset\n)\n\ntrainer.train()\n</code></pre>"},{"location":"Getting-Started/","title":"Getting Started","text":"<p>There are a couple of ways to apply Liger kernels, depending on the level of customization required.</p>"},{"location":"Getting-Started/#1-use-autoligerkernelforcausallm","title":"1. Use AutoLigerKernelForCausalLM","text":"<p>Using the <code>AutoLigerKernelForCausalLM</code> is the simplest approach, as you don't have to import a model-specific patching API. If the model type is supported, the modeling code will be automatically patched using the default settings.</p> <p>Example</p> <pre><code>from liger_kernel.transformers import AutoLigerKernelForCausalLM\n\n# This AutoModel wrapper class automatically monkey-patches the\n# model with the optimized Liger kernels if the model is supported.\nmodel = AutoLigerKernelForCausalLM.from_pretrained(\"path/to/some/model\")\n</code></pre>"},{"location":"Getting-Started/#2-apply-model-specific-patching-apis","title":"2. Apply Model-Specific Patching APIs","text":"<p>Using the patching APIs, you can swap Hugging Face models with optimized Liger Kernels.</p> <p>Example</p> <pre><code>import transformers\nfrom liger_kernel.transformers import apply_liger_kernel_to_llama\n\n# 1a. Adding this line automatically monkey-patches the model with the optimized Liger kernels\napply_liger_kernel_to_llama()\n\n# 1b. You could alternatively specify exactly which kernels are applied\napply_liger_kernel_to_llama(\n  rope=True,\n  swiglu=True,\n  cross_entropy=True,\n  fused_linear_cross_entropy=False,\n  rms_norm=False\n)\n\n# 2. Instantiate patched model\nmodel = transformers.AutoModelForCausalLM(\"path/to/llama/model\")\n</code></pre>"},{"location":"Getting-Started/#3-compose-your-own-model","title":"3. Compose Your Own Model","text":"<p>You can take individual kernels to compose your models.</p> <p>Example</p> <pre><code>from liger_kernel.transformers import LigerFusedLinearCrossEntropyLoss\nimport torch.nn as nn\nimport torch\n\nmodel = nn.Linear(128, 256).cuda()\n\n# fuses linear + cross entropy layers together and performs chunk-by-chunk computation to reduce memory\nloss_fn = LigerFusedLinearCrossEntropyLoss()\n\ninput = torch.randn(4, 128, requires_grad=True, device=\"cuda\")\ntarget = torch.randint(256, (4, ), device=\"cuda\")\n\nloss = loss_fn(model.weight, input, target)\nloss.backward()\n</code></pre>"},{"location":"High-Level-APIs/","title":"High Level APIs","text":""},{"location":"High-Level-APIs/#automodel","title":"AutoModel","text":"AutoModel Variant API AutoModelForCausalLM <code>liger_kernel.transformers.AutoLigerKernelForCausalLM</code> <p>This API extends the implementation of the <code>AutoModelForCausalLM</code> within the <code>transformers</code> library from Hugging Face.</p> <p>Try it Out</p> <p>You can experiment as shown in this example here.</p>"},{"location":"High-Level-APIs/#patching","title":"Patching","text":"<p>You can also use the Patching APIs to use the kernels for a specific model architecture.</p> <p>Try it Out</p> <p>You can experiment as shown in this example here.</p> Model API Supported Operations LLaMA 2 &amp; 3 <code>liger_kernel.transformers.apply_liger_kernel_to_llama</code> RoPE, RMSNorm, SwiGLU, CrossEntropyLoss, FusedLinearCrossEntropy LLaMA 3.2-Vision <code>liger_kernel.transformers.apply_liger_kernel_to_mllama</code> RoPE, RMSNorm, SwiGLU, CrossEntropyLoss, FusedLinearCrossEntropy Mistral <code>liger_kernel.transformers.apply_liger_kernel_to_mistral</code> RoPE, RMSNorm, SwiGLU, CrossEntropyLoss, FusedLinearCrossEntropy Mixtral <code>liger_kernel.transformers.apply_liger_kernel_to_mixtral</code> RoPE, RMSNorm, SwiGLU, CrossEntropyLoss, FusedLinearCrossEntropy Gemma1 <code>liger_kernel.transformers.apply_liger_kernel_to_gemma</code> RoPE, RMSNorm, GeGLU, CrossEntropyLoss, FusedLinearCrossEntropy Gemma2 <code>liger_kernel.transformers.apply_liger_kernel_to_gemma2</code> RoPE, RMSNorm, GeGLU, CrossEntropyLoss, FusedLinearCrossEntropy Qwen2, Qwen2.5, &amp; QwQ <code>liger_kernel.transformers.apply_liger_kernel_to_qwen2</code> RoPE, RMSNorm, SwiGLU, CrossEntropyLoss, FusedLinearCrossEntropy Qwen2-VL <code>liger_kernel.transformers.apply_liger_kernel_to_qwen2_vl</code> RMSNorm, LayerNorm, SwiGLU, CrossEntropyLoss, FusedLinearCrossEntropy Phi3 &amp; Phi3.5 <code>liger_kernel.transformers.apply_liger_kernel_to_phi3</code> RoPE, RMSNorm, SwiGLU, CrossEntropyLoss, FusedLinearCrossEntropy"},{"location":"Low-Level-APIs/","title":"Low Level APIs","text":""},{"location":"Low-Level-APIs/#model-kernels","title":"Model Kernels","text":"Kernel API RMSNorm <code>liger_kernel.transformers.LigerRMSNorm</code> LayerNorm <code>liger_kernel.transformers.LigerLayerNorm</code> RoPE <code>liger_kernel.transformers.liger_rotary_pos_emb</code> SwiGLU <code>liger_kernel.transformers.LigerSwiGLUMLP</code> GeGLU <code>liger_kernel.transformers.LigerGEGLUMLP</code> CrossEntropy <code>liger_kernel.transformers.LigerCrossEntropyLoss</code> Fused Linear CrossEntropy <code>liger_kernel.transformers.LigerFusedLinearCrossEntropyLoss</code> Sparsemax <code>liger_kernel.transformers.LigerSparsemax</code>"},{"location":"Low-Level-APIs/#rms-norm","title":"RMS Norm","text":"<p>RMS Norm simplifies the LayerNorm operation by eliminating mean subtraction, which reduces computational complexity while retaining effectiveness. </p> <p>This kernel performs normalization by scaling input vectors to have a unit root mean square (RMS) value. This method allows for a ~7x speed improvement and a ~3x reduction in memory footprint compared to implementations in PyTorch.</p> <p>Try it out</p> <p>You can experiment as shown in this example here.</p>"},{"location":"Low-Level-APIs/#rope","title":"RoPE","text":"<p>RoPE (Rotary Position Embedding) enhances the positional encoding used in transformer models.</p> <p>The implementation allows for effective handling of positional information without incurring significant computational overhead.</p> <p>Try it out</p> <p>You can experiment as shown in this example here.</p>"},{"location":"Low-Level-APIs/#swiglu","title":"SwiGLU","text":""},{"location":"Low-Level-APIs/#geglu","title":"GeGLU","text":""},{"location":"Low-Level-APIs/#crossentropy","title":"CrossEntropy","text":"<p>This kernel is optimized for calculating the loss function used in classification tasks. </p> <p>The  kernel achieves a ~3x execution speed increase and a ~5x reduction in memory usage for substantial vocabulary sizes compared to implementations in PyTorch.</p> <p>Try it out</p> <p>You can experiment as shown in this example here.</p>"},{"location":"Low-Level-APIs/#fused-linear-crossentropy","title":"Fused Linear CrossEntropy","text":"<p>This kernel combines linear transformations with cross-entropy loss calculations into a single operation.</p> <p>Try it out</p> <p>You can experiment as shown in this example here</p>"},{"location":"Low-Level-APIs/#sparsemax","title":"Sparsemax","text":"<p>Sparsemax is a sparse alternative to softmax that produces sparse probability distributions. This kernel implements an efficient version of the sparsemax operation that can be used as a drop-in replacement for softmax in attention mechanisms or classification tasks.</p> <p>The implementation achieves significant speed improvements and memory savings compared to standard PyTorch implementations, particularly for large input tensors.</p>"},{"location":"Low-Level-APIs/#alignment-kernels","title":"Alignment Kernels","text":"Kernel API Fused Linear CPO Loss <code>liger_kernel.chunked_loss.LigerFusedLinearCPOLoss</code> Fused Linear DPO Loss <code>liger_kernel.chunked_loss.LigerFusedLinearDPOLoss</code> Fused Linear ORPO Loss <code>liger_kernel.chunked_loss.LigerFusedLinearORPOLoss</code> Fused Linear SimPO Loss <code>liger_kernel.chunked_loss.LigerFusedLinearSimPOLoss</code>"},{"location":"Low-Level-APIs/#distillation-kernels","title":"Distillation Kernels","text":"Kernel API KLDivergence <code>liger_kernel.transformers.LigerKLDIVLoss</code> JSD <code>liger_kernel.transformers.LigerJSD</code> Fused Linear JSD <code>liger_kernel.transformers.LigerFusedLinearJSD</code>"},{"location":"Low-Level-APIs/#experimental-kernels","title":"Experimental Kernels","text":"Kernel API Embedding <code>liger_kernel.transformers.experimental.LigerEmbedding</code> Matmul int2xint8 <code>liger_kernel.transformers.experimental.matmul</code>"},{"location":"acknowledgement/","title":"Acknowledgement","text":""},{"location":"acknowledgement/#design","title":"Design","text":"<ul> <li>@claire_yishan for the LOGO design</li> <li>Wave Snippets for generating the animated code snippets</li> </ul>"},{"location":"acknowledgement/#code","title":"Code","text":"<p>We referenced or used the following projects:</p> # Project Description Location License 1 Unsloth <code>calculate_settings</code> to determine block size and warp; We reuse it for Norm and MLP Liger Kernel Utils Apache 2 Unsloth We modified and added dW calculation on top of Unsloth implementation Liger Kernel RMS Norm Apache 3 Triton tutorial We modified on top of triton tutorials Liger Kernel RMS Norm MIT 4 tiny shakespeare dataset We use tiny shakespeare dataset to conduct convergence test on mini model Liger Kernel Convergence N/A 5 Efficient Cross Entropy We use the idea of gradient-in-forward and chunking Liger Kernel Linear Cross Entropy MIT 6 Flash attn We take many optimization ideas from the work, such as tiling and recomputation BSD 7 AutoAWQ We reference the design of automodel Liger Kernel Auto Model MIT 8 llm.c We reference the design of end-to-end testing Liger Kernel Convergence Tests MIT <p>Many thanks to the contributors to these projects for their invaluable work that helped make Liger possible.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to Liger-Kernel! This guide will help you set up your development environment, add a new kernel, run tests, and submit a pull request (PR).</p> <p>Note</p>"},{"location":"contributing/#maintainers","title":"Maintainers","text":"<p>@ByronHsu(admin) @qingquansong @yundai424 @kvignesh1420 @lancerts @JasonZhu1313 @shimizust</p>"},{"location":"contributing/#interested-in-the-ticket","title":"Interested in the ticket?","text":"<p>Leave <code>#take</code> in the comment and tag the maintainer. </p>"},{"location":"contributing/#setting-up-your-development-environment","title":"Setting Up Your Development Environment","text":"<p>Note</p> <ol> <li>Clone the Repository <code>sh git clone https://github.com/linkedin/Liger-Kernel.git cd Liger-Kernel</code></li> <li>Install Dependencies and Editable Package <pre><code>pip install . -e[dev]\n</code></pre>  If encounter error <code>no matches found: .[dev]</code>, please use  <pre><code>pip install -e .'[dev]'\n</code></pre></li> </ol>"},{"location":"contributing/#structure","title":"Structure","text":"<p>Info</p>"},{"location":"contributing/#source-code","title":"Source Code","text":"<ul> <li><code>ops/</code>: Core Triton operations.</li> <li><code>transformers/</code>: PyTorch <code>nn.Module</code> implementations built on Triton operations, compliant with the <code>transformers</code> API.</li> </ul>"},{"location":"contributing/#tests","title":"Tests","text":"<ul> <li><code>transformers/</code>: Correctness tests for the Triton-based layers.</li> <li><code>convergence/</code>: Patches Hugging Face models with all kernels, runs multiple iterations, and compares weights, logits, and loss layer-by-layer.</li> </ul>"},{"location":"contributing/#benchmark","title":"Benchmark","text":"<ul> <li><code>benchmark/</code>: Execution time and memory benchmarks compared to Hugging Face layers.</li> </ul>"},{"location":"contributing/#adding-support-for-a-new-model","title":"Adding support for a new model","text":"<p>To get familiar with the folder structure, please refer here.</p>"},{"location":"contributing/#1-figure-out-the-kernels-that-can-be-monkey-patched","title":"1 Figure out the kernels that can be monkey-patched","text":"<p>a) Check the <code>src/liger_kernel/ops</code> directory to find the kernels that can be monkey-patched.</p> <p>b) Kernels like Fused Linear Cross Entropy require a custom lce_forward function to allow monkey-patching. For adding kernels requiring a similar approach, ensure that you create the corresponding forward function in the <code>src/liger_kernel/transformers/model</code> directory.</p>"},{"location":"contributing/#2-monkey-patch-the-huggingface-model","title":"2 Monkey-patch the HuggingFace model","text":"<p>a) Add the monkey-patching code in the <code>src/liger_kernel/transformers/monkey_patch.py</code> file.</p> <p>b) Ensure that the monkey-patching function is added to the <code>__init__.py</code> file in the <code>src/liger_kernel/transformers/</code> directory.</p>"},{"location":"contributing/#3-add-unit-tests","title":"3 Add Unit Tests","text":"<p>a) Create unit tests and convergence tests for the monkey-patched model in the tests directory. Ensure that your tests cover all functionalities of the monkey-patched model.</p>"},{"location":"contributing/#adding-a-new-kernel","title":"Adding a New Kernel","text":"<p>To get familiar with the folder structure, please refer here.</p> <ol> <li> <p>Create Your Kernel Add your kernel implementation in <code>src/liger_kernel/</code>.</p> </li> <li> <p>Add Unit Tests Create unit tests and convergence tests for your kernel in the tests directory. Ensure that your tests cover all kernel functionalities.</p> </li> <li> <p>Add Benchmark Script Add a benchmarking script under <code>benchmark/scripts</code> using the naming convention <code>benchmark_{kernel_name}.py</code> showing the performance difference between the Liger kernel and HuggingFace.</p> </li> </ol>"},{"location":"contributing/#run-tests","title":"Run tests","text":""},{"location":"contributing/#use-makefile-to-run-full-tests","title":"Use Makefile to run full tests","text":"<ol> <li>Run <code>make test</code> to ensure correctness.</li> <li>Run <code>make checkstyle</code> to ensure code style.</li> <li>Run <code>make test-convergence</code> to ensure convergence.</li> </ol>"},{"location":"contributing/#run-pytest-on-single-file","title":"Run pytest on single file","text":"<p><code>python -m pytest test_sample.py::test_function_name</code></p>"},{"location":"contributing/#run-kernel-benchmarks","title":"Run kernel benchmarks","text":"<p>The <code>/benchmark</code> directory contains benchmarking scripts for the individual kernels, demonstrating differences in speed and memory usage between using Liger and HuggingFace module implementations.</p> <ol> <li>Run <code>make run-benchmarks</code> to run all benchmarking scripts and append data to <code>benchmark/data/all_benchmark_data.csv</code>.</li> <li>Existing entries that are the same (based on <code>kernel_name</code>, <code>kernel_provider</code>, <code>kernel_operation_mode</code>, <code>metric_name</code>, <code>x_name</code>, <code>x_value</code>, <code>extra_benchmark_config_str</code>, and <code>gpu_name</code>) will not be overwritten.</li> <li>Run <code>make run-benchmarks OVERWRITE=1</code> to overwrite any existing entries that have the same configuration.</li> <li>Run <code>python benchmark/scripts/benchmark_{kernel_name}.py</code> to run an individual benchmark.</li> <li>You can use the <code>benchmark/benchmarks_visualizer.py</code> script to generate visualizations from the CSV, these are then saved to the <code>benchmark/visualizations</code> directory (note: this directory is not tracked by git).</li> </ol>"},{"location":"contributing/#submit-pr","title":"Submit PR","text":"<p>Fork the repo, copy and paste the successful test logs in the PR and submit the PR followed by the PR template (example PR).</p> <p>Notice</p> <p>As a contributor, you represent that the code you submit is your original work or that of your employer (in which case you represent you have the right to bind your employer). By submitting code, you (and, if applicable, your employer) are licensing the submitted code to LinkedIn and the open source community subject to the BSD 2-Clause license.</p>"},{"location":"contributing/#release-maintainer-only","title":"Release (Maintainer only)","text":"<ol> <li>Bump the version in pyproject.toml to the desired version (for example, <code>0.2.0</code>)</li> <li>Submit a PR and merge</li> <li>Create a new release based on the current HEAD, tag name using <code>v&lt;version number&gt;</code> for example <code>v0.2.0</code>. Alternatively, If you want to create release based on a different commit hash, <code>git tag v0.2.0 &lt;commit hash&gt; &amp;&amp; git push origin v0.2.0</code>, and create release based on this tag</li> <li>Adding release note: Minimum requirement is to click the <code>Generate Release Notes</code> button that will automatically generates 1) changes included, 2) new contributors. It's good to add sections on top to highlight the important changes.</li> <li>New pip uploading will be triggered upon a new release. NOTE: Both pre-release and official release will trigger the workflow to build wheel and publish to pypi, so please be sure that step 1-3 are followed correctly!</li> </ol> <p>Notes on version</p> <p>Here we follow the sematic versioning. Denote the version as <code>major.minor.patch</code>, we increment:</p> <ul> <li>Major version when there is backward incompatible change.</li> <li>Minor version when there is new backward-compatible functionality.</li> <li>Patch version for bug fixes.</li> </ul>"},{"location":"license/","title":"License","text":"<p>This project is licensed under the BSD 2-CLAUSE License (see <code>LICENSE</code> for details). It also includes components from projects licensed under:</p> <ul> <li>Apache License 2.0 (see <code>LICENSE-APACHE-2.0</code> for details).</li> <li>MIT License (see <code>LICENSE-MIT-AutoAWQ</code> for details).</li> <li>MIT License (see <code>LICENSE-MIT-Efficient Cross Entropy</code> for details).</li> <li>MIT License (see <code>LICENSE-MIT-llmc</code> for details).</li> <li>MIT License (see <code>LICENSE-MIT-triton</code> for details).</li> </ul>"}]}